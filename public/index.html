<html>
<script src='http://res.wx.qq.com/open/js/jweixin-1.4.0.js'></script>
<script>
  window.SHA1 = (function () {

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS 180-1
     * Version 2.2 Copyright Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */

    // Convert a raw string to a hex string
    function rawToHex(raw) {
      var hex = "";
      var hexChars = "0123456789abcdef";
      for (var i = 0; i < raw.length; i++) {
        var c = raw.charCodeAt(i);
        hex += (
          hexChars.charAt((c >>> 4) & 0x0f) +
          hexChars.charAt(c & 0x0f));
      }
      return hex;
    }

    // Calculate the SHA1 of a raw string
    function sha1Raw(raw) {
      return binaryToRaw(sha1Binary(rawToBinary(raw), raw.length * 8));
    }

    /*
     * Convert an array of big-endian words to a string
     */
    function binaryToRaw(bin) {
      var raw = "";
      for (var i = 0, il = bin.length * 32; i < il; i += 8) {
        raw += String.fromCharCode((bin[i >> 5] >>> (24 - i % 32)) & 0xff);
      }
      return raw;
    }

    /*
     * Calculate the SHA-1 of an array of big-endian words, and a bit length
     */
    function sha1Binary(bin, len) {
      // append padding
      bin[len >> 5] |= 0x80 << (24 - len % 32);
      bin[((len + 64 >> 9) << 4) + 15] = len;

      var w = new Array(80);
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      var e = -1009589776;

      for (var i = 0, il = bin.length; i < il; i += 16) {
        var _a = a;
        var _b = b;
        var _c = c;
        var _d = d;
        var _e = e;

        for (var j = 0; j < 80; j++) {
          if (j < 16) {
            w[j] = bin[i + j];
          } else {
            w[j] = _rotateLeft(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
          }
          var t = _add(_add(_rotateLeft(a, 5), _ft(j, b, c, d)),
            _add(_add(e, w[j]), _kt(j)));
          e = d;
          d = c;
          c = _rotateLeft(b, 30);
          b = a;
          a = t;
        }

        a = _add(a, _a);
        b = _add(b, _b);
        c = _add(c, _c);
        d = _add(d, _d);
        e = _add(e, _e);
      }
      return [a, b, c, d, e];
    }

    // Add integers, wrapping at 2^32. This uses 16-bit operations internally
    // to work around bugs in some JS interpreters.
    function _add(x, y) {
      var lsw = (x & 0xFFFF) + (y & 0xFFFF);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function _rotateLeft(n, count) {
      return (n << count) | (n >>> (32 - count));
    }

    /*
     * Perform the appropriate triplet combination function for the current
     * iteration
     */
    function _ft(t, b, c, d) {
      if (t < 20) {
        return (b & c) | ((~b) & d);
      } else if (t < 40) {
        return b ^ c ^ d;
      } else if (t < 60) {
        return (b & c) | (b & d) | (c & d);
      } else {
        return b ^ c ^ d;
      }
    }

    /*
     * Determine the appropriate additive constant for the current iteration
     */
    function _kt(t) {
      if (t < 20) {
        return 1518500249;
      } else if (t < 40) {
        return 1859775393;
      } else if (t < 60) {
        return -1894007588;
      } else {
        return -899497514;
      }
    }

    // Convert a raw string to an array of big-endian words.
    // Characters >255 have their high-byte silently ignored.
    function rawToBinary(raw) {
      var binary = new Array(raw.length >> 2);
      for (var i = 0, il = binary.length; i < il; i++) {
        binary[i] = 0;
      }
      for (i = 0, il = raw.length * 8; i < il; i += 8) {
        binary[i >> 5] |= (raw.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
      }
      return binary;
    }

    // Encode a string as UTF-8.
    // For efficiency, this assumes the input is valid UTF-16.
    function stringToRaw(string) {
      var raw = "", x, y;
      var i = -1;
      var il = string.length;
      while (++i < il) {
        // decode UTF-16 surrogate pairs
        x = string.charCodeAt(i);
        y = i + 1 < il ? string.charCodeAt(i + 1) : 0;
        if (0xd800 <= x && x <= 0xdbff && 0xdc00 <= y && y <= 0xdfff) {
          x = 0x10000 + ((x & 0x03ff) << 10) + (y & 0x03ff);
          ++i;
        }
        // encode output as UTF-8
        if (x <= 0x7f) {
          raw += String.fromCharCode(x);
        } else if (x <= 0x7ff) {
          raw += String.fromCharCode(0xc0 | ((x >>> 6) & 0x1f),
            0x80 | (x & 0x3f));
        } else if (x <= 0xffff) {
          raw += String.fromCharCode(0xe0 | ((x >>> 12) & 0x0f),
            0x80 | ((x >>> 6) & 0x3f),
            0x80 | (x & 0x3f));
        } else if (x <= 0x1fffff) {
          raw += String.fromCharCode(0xf0 | ((x >>> 18) & 0x07),
            0x80 | ((x >>> 12) & 0x3f),
            0x80 | ((x >>> 6) & 0x3f),
            0x80 | (x & 0x3f));
        }
      }
      return raw;
    }

    // Calculate the HMAC-SHA1 of a key and some data (raw strings)
    function hmacRaw(key, data) {
      var binaryKey = rawToBinary(key);
      if (binaryKey.length > 16) {
        binaryKey = sha1Binary(binaryKey, key.length * 8);
      }
      var ipad = new Array(16);
      var opad = new Array(16);
      for (var i = 0; i < 16; i++) {
        ipad[i] = binaryKey[i] ^ 0x36363636;
        opad[i] = binaryKey[i] ^ 0x5c5c5c5c;
      }
      var hash = sha1Binary(ipad.concat(rawToBinary(data)), 512 + data.length * 8);
      return binaryToRaw(sha1Binary(opad.concat(hash), 512 + 160));
    }

    var tests = {
      hmac: {
        "fbdb1d1b18aa6c08324b7d64b71fb76370690e1d":
          ["", ""],
        "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9":
          ["key", "The quick brown fox jumps over the lazy dog"]
      },
      sha1: {
        "da39a3ee5e6b4b0d3255bfef95601890afd80709":
          "",
        "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12":
          "The quick brown fox jumps over the lazy dog",
      }
    };

    return {
      sha1: function (s) {
        return rawToHex(sha1Raw(stringToRaw(s)));
      },

      sha1Hex: function (value) {
        return rawToHex(sha1Raw(this.hexToString(value)));
      },

      hmac: function (k, d) {
        return rawToHex(hmacRaw(stringToRaw(k), stringToRaw(d)));
      },

      hexToString: function (hex) {
        var str = '';
        for (var i = 0, il = hex.length; i < il; i += 2) {
          str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
        }
        return str;
      },

      test: function () {
        var success = true;
        for (var expectedOutput in tests.sha1) {
          if (tests.sha1.hasOwnProperty(expectedOutput)) {
            var input = tests.sha1[expectedOutput];
            var output = this.sha1(input).toLowerCase();
            if (output !== expectedOutput) {
              console.error(
                "sha1(" + input + ") was " + output +
                " (expected: " + expectedOutput + ")");
              success = false;
            }
          }
        }
        for (var expectedOutput in tests.hmac) {
          if (tests.hmac.hasOwnProperty(expectedOutput)) {
            var input = tests.hmac[expectedOutput];
            var output = this.hmac(input[0], input[1]).toLowerCase();
            if (output !== expectedOutput) {
              console.error(
                "hmac(" + input[0] + ", " + input[1] + ") was " + output +
                " (expected: " + expectedOutput + ")");
              success = false;
            }
          }
        }
        return success;
      }
    };

  })();
</script>
<script>
  function init(jsApiList) {
    let appId = 'wx661994a569e2f0e3';
    let appsecret = '4ee9efca1c18ade6b163603dfb217522';
    let api_ticket = 'LIKLckvwlJT9cWIhEQTwfHF6H3gaYd3_JsAM1UCGF3-jTYq6sI1z26YC6M_-ybUi_sCYkd4k596mQ7q8c668fg';
    let nonceStr = 'tgCKCDO9AKffs3ZqCIWbPDIQAcJZ18iX3tVZr4DgGP4';
    let timestamp = Math.floor(new Date().getTime() / 1000);
    let url = location.href;//'http://uatfront.sg.work';
    // console.log('wx, url: ', wx, url);
    signature = SHA1.sha1(`jsapi_ticket=${api_ticket}&noncestr=${nonceStr}&timestamp=${timestamp}&url=${url}`);
    //   ************测试用
    wx.config({
      debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
      appId, // 必填，公众号的唯一标识
      timestamp, // 必填，生成签名的时间戳
      nonceStr, // 必填，生成签名的随机串
      signature, // 必填，签名
      jsApiList // 必填，需要使用的JS接口列表
    });
  }
  init(['onMenuShareAppMessage', 'updateAppMessageShareData']);

  wx.ready(function () {
    console.log('wx ready');
    // wx.hideMenuItems({
    //   menuList: ['menuItem:share:appMessage'] // 要显示的菜单项，所有menu项见附录3
    // });
    // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。
    wx.updateAppMessageShareData({
      title: '添加协作者', // 分享标题
      desc: '点击进去，参与协作', // 分享描述
      link: 'www.zhai.com/login', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致
      imgUrl: 'https://www.wangbase.com/blogimg/asset/201808/bg2018080601.jpg', // 分享图标
      success: function () {
        console.log('设置分享message成功！！！');
        // 设置成功
      }
    })
  });

  wx.error(function (res) {
    console.log('error: ', res);
    // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。
  });

</script>

<body>
  <div style="font-size:20px;">
    Welcome!!
  </div>
</body>

</html>
